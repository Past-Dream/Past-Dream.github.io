# 《计算机系统基础》课程最后一讲

## 试卷结构

近年《计算机系统基础》试卷结构常见格式如下：

- 选择题：10题，每题2分，共20分
- 简答题：1题，每题80分，共80分

考试形式为开卷，时长120分钟。开卷考试仅允许携带主教材《计算机系统基础》（第2版），不允许携带《计算机系统基础学习指导与习题解答》。

考试范围广泛，涉及了计算机系统基础课程中几乎所有内容。选择题组织体系较散，跨越性较大；简答题涉及内容较广，通常会给出一个C语言程序及其编译后的部分汇编代码并围绕此设问。

因此，读懂程序以及对应的汇编代码是简答题的得分关键。这需要我们掌握汇编指令、寄存器、内存地址、寻址方式、系统调用等知识。不过，如果你在本学期中独立自主认真完成了`lab`实验，那么读懂程序和汇编代码应该不成问题。

我们需要掌握一些基础知识点，做到相关问题闭卷也可以很好作答——事实上，开卷考试的时间并非完全充裕，对于一些常见的知识我们需要不借助书本直接作答，如cache、段页式虚存管理等。

## 常见简答题
!!! question "样卷简答题（2017）"
    在执行 bubsort 程序过程中，是否会陷入内核执行？计算机系统如何实现 fread 函数的功能（要求从调用 fread 库函数开始简要说明，包括对应哪个系统调用、如何从用户态陷入内核态、内核的大致处理过程等。200 字左右）？

在执行 bubsort 程序过程中，会陷入内核执行。

fread 库函数最终会调用系统调用封装函数 read()，该封装函数由若干 mov 指令和一条 int 0x80 指令以及其他指令序列组成。int 指令前面的若干 mov 指令用于将 read 系统调用的参数送到相应寄存器中，执行到 int 指令时，便从用户态陷入内核态，在内核中，通过系统调用号跳转到 sys_read 服务例程执行，sys_read 服务例程主要有三个部分组成：设备无关软件、设备驱动程序和中断服务程序。最终完成读取磁盘文件的操作。

!!! question "往年卷简答题（2018/2024）"
    “段故障”在IA-32中的中断类型号是多少？在Linux中的信号名是什么？IA-32+Linux平台中的硬/软件是如何检测、响应和处理该段故障的？(要求从执行段故障指令开始达行说明，包括地址转换、保护错检测、异常响应及处理等过程，300字左右)

中断类型号是13，信号名为SIGSEGV。

第一步检测到发生“段故障”。IA-32采用段页式虚拟地址管理方式，因此，先通过查询段描述符表将48位逻辑地址转换为线性地址；然后，通过查询页表将线性地址转换为物理地址，在MMU进行地址转换时，若发现用户进程访问了不该访问的页面，或进行了与访问权限不相符的访问，则检测到存储保护错，从而产生13号中断(即段故障)。

第二步响应“段故障”异常。CPU根据中断类型号13,找到IDT中的第13个表项，CPU将用户栈的栈顶信息保存到内核栈中，并将当前的断点(CS:EIP)和机器状态(EFLAGS)保存到内核栈顶，发生故障的线性地址保存到CR2中，最后将IDT表项中的段选择符和偏移地址分别装入CS和EIP,从而转到段故障处理程序执行。

第三步处理“段故障”异常。Linux中采用信号机制进行异常处理，在对应的异常处理程序general_protection中会发一个“SIGSEGV”信号给用户进程，然后返回到用户进程执行。用户进程接受到一个信号后，会转到“SIGSEGV”对应的信号处理程序去执行，该信号处理程序在屏幕上输出“segmentation fault”后，终止程序的执行。

!!! question "往年卷简答题（2018）"
    简述第1次执行printf函数的整个过程，并说明第2次以后执行printf函数的过程与第1次执行过程有什么不同。(150字左右)

第1次执行printf函数，需要执行动态链接延迟绑定代码，以对printf函数进行重定位，将printf函数的首地址填到对应的GDT表项中，然后转到printf函数执行。printf函数最终要调用write系统调用封装函数，其中有一条int 0x80指令，执行该指令后就陷入内核执行系统调用处理程序行system_call,然后，根据系统调用号4,跳转到sys_write执行，在内核经过设备无关层、设备驱动程序层，通过驱动1/O外设进行I/O处理。第2次以后执行printf函数无需进行重定位。